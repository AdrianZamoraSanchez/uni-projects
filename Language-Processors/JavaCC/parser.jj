/*
 * Programa parser.jj 
 * Creado por: Adrián Zamora Sánchez
 *
 * El programa consiste en un microcompilador para un lenguaje 
 * sencillo que se asemeja a COBOL
 *
 * Las diferencias con los outputs que se dan de ejemplos correctos
 * difieren únicamente en la numeración de las etiquetas de bucles
 * VARYING anidados
 *
 * La práctica se ha realizado utilizando:
 *   - JavaCC v7.0.121.0.4
 *   - Java openJDK v21.0.4 2024-07-16
 */

// Opciones del parser
options {
	BUILD_TOKEN_MANAGER=true;
	COMMON_TOKEN_ACTION=false;
}

// Parser del lenguaje similar a COBOL
PARSER_BEGIN(CobolParser)
// Imports necesarios
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;

public class CobolParser {
  // Variable global que cuenta las etiquetas de salto LBL
  static int etiqueta = 0;

  public static void main(String[] args) throws ParseException {
    // Variable que contiene la entrada del programa, 
    // por defecto se toma la entrada estándar del sistema
    InputStream inputStream = System.in;

    // Se comprueba si la entrada es mediante una ruta o por la entrada estándar
    if(args.length > 0){
      // El primer argumento será la ruta al archivo
      String filePath = args[0];
      
      try{
        // Se abre el archivo de la ruta como un inputStream
        inputStream = new FileInputStream(new File(filePath));
      } catch(IOException error){
        // Se muestra el error al utilizar el archivo
        System.out.println("Error al leer el archivo de entrada: " + error.getMessage());
      }
    }

    // Se genera el objeto del parser y se le pasa el input 
    CobolParser parser = new CobolParser(inputStream);

    // Instrucción que inicia el reconocimiento de la entrada
    parser.program();
  }
      
  
  // Función que evalua una lista de Tokens para mostrar el operador correcto
  static void evalExpr(List<Token> opList){
    if(opList.size() >= 2) {
      // Se extrae el siguiente elemento (el operador)
      String op = opList.get(1).image;
      
      // Se genera la instrucción correcta
      if(op == "+"){System.out.println("add");}
      if(op == "-"){System.out.println("sub");}
      if(op == "/"){System.out.println("div");}
      if(op == "*"){System.out.println("mul");}
      
      // Se vacía la lista
      opList.clear();
    }
  }
}

PARSER_END(CobolParser)

// Skips generales
SKIP : {
  " " 
| "\n"
| "\t" 
| "\r"
}

// Skips de comentarios
SKIP : {
  // Comentarios tipo *> hasta el final de la línea
  <COMMENT : "*>" (~["\n", "\r"])* >
| <COMMENT_COBOL : "      *" (~["\n","\r"])* >
}

// Palabras reservadas del lenguaje
TOKEN : {
  <PROGRAM : "PROGRAM">
| <BEGIN : "BEGIN">
| <IF : "IF"> 
| <THEN : "THEN">
| <ELSE : "ELSE"> 
| <DISPLAY : "DISPLAY"> 
| <ACCEPT : "ACCEPT">  
| <WHILE : "WHILE">
| <DO : "DO">
| <VARYING : "VARYING"> 
| <BY : "BY">
| <END : "END"> 
| <MOVE : "MOVE"> 
| <TO : "TO"> 
| <FROM : "FROM">
| <IS : "IS">
| <NOT : "NOT">
| <GREATER : "GREATER">
| <LESS : "LESS">
| <EQUAL : "EQUAL">
| <THAN : "THAN">
| <GIVING : "GIVING">
| <SUBTRACT : "SUBTRACT">
| <ADD : "ADD">
| <MULTIPLY : "MULTIPLY">
| <DIVIDE : "DIVIDE">
}

// Tokens para identificadores, valores números y string
TOKEN : {
   <#let: ["A"-"Z"]>
|  <#num: ["0"-"9"]>
|  <ID : (<let>)(<let>|<num>|"-")*(<let>|<num>)? >
|  <CAD : "\"" (~["\""])* "\"" | "\'" (~["\'"])* "\'">
|  <NUM : (<num>)+ >
}

// Operadores lógicos
TOKEN : {
  <PLUS : "+">
| <MINUS : "-">
| <PRODUCT : "*">
| <DIVISION : "/">
| <BOOL : ("false"|"true")>
}

// Aceptador de la estructura del programa
void program() : {}
{ 
  <PROGRAM>
  <ID>(".")
  <BEGIN>
  stmts()
  <END>
  <EOF>
}

// Conjunto de statements 
void stmts() : {}
{
  (LOOKAHEAD(2) stmt())+
}

// Statement único
void stmt() : {}
{
  ( loop() 
  | cond() 
  | assig() 
  | io()
  ) 
  (".")
}

// Aceptador de bucles
void loop() : {
  // Variables utilizadas como contador para las etiquetas de salto (LBL) 
  int LBLinicio = 0;
  int LBLfin = 0;
  
  // Variables de VARYING
  Token controlVar = null; // Contiene la variable de control
  Token origVar = null;   // Contiene el valor de origen de la variable de control
  Token inc = null;        // Contiene el valor del incremento de la var. de control
  Token limit = null;      // Contiene el limite (valor de parada) del bucle
}
{
  // Lógica de WHILE
  (<WHILE> {
    // Se establece y muestra la etiqueta de comienzo del código en el bucle
    LBLinicio = etiqueta++; 
    System.out.println("\nLBL"+ LBLinicio +":");
  } 
  (booleanExpr()) {
    // Se establece y muestra la etiqueta de salto en caso de que no se entra al bucle
    LBLfin = etiqueta++;
    System.out.println("sifalsovea LBL"+ LBLfin);
  }

  // Lógica de VARAYING 
| <VARYING> controlVar = <ID>{System.out.println("valori " + controlVar.image);}
  (<FROM> (origVar = atomic() {System.out.println("valord " + origVar);}))? 
  <TO> {
    // Se comprueba si es una inicialización de la variable de control por defecto
    if(origVar == null){
      // Asignación por defecto de la variable de control, comienza en 1
      System.out.println("mete 1");
    }
      System.out.println("asigna");
  }  
  limit = atomic()
  (<BY> (inc = atomic()))?
  )
  <DO> {
      if(controlVar != null){
        LBLinicio = etiqueta++;
        System.out.println("\nLBL" + LBLinicio + ":");
      }
    } 
  ((stmts())+) {
    /* Se muestra todo el código que corresponde al incremento de la 
       variable de control en VARYING */
    if(controlVar != null){
      System.out.println("valori " + controlVar);
      System.out.println("valord " + controlVar);

      // Se comprueba si se ha pasado incremento o es el por defecto
      if(inc == null){System.out.println("mete 1");}
      else{System.out.println("mete " + inc);}

      System.out.println("add");
      System.out.println("asigna");
      System.out.println("valord " + controlVar);
      System.out.println("mete " + limit);
      System.out.println("esmenor");
      System.out.println("siciertovea LBL" + LBLinicio);
    }
  } 
  <END> {  
    // Si el bucle es un WHILE muesta la etiqueta de vea LBLx
    if(controlVar == null){
      System.out.println("vea LBL" + LBLinicio);
      System.out.println("\nLBL" + LBLfin + ":");
    }
  }
}

// Aceptador de operadores condicionales
void cond() : {
  // Variables que establecen los contadores de las etiquetas de salto (LBL)
  int LBLfalso = 0;
  int LBLfin = 0;
}
{
  <IF>
  booleanExpr() {
    // Se establece y muestra la etiqueta de salto en caso de condición de IF falsa
    LBLfalso = etiqueta++; 
    System.out.println("sifalsovea LBL" + LBLfalso);
  }
  <THEN> 
  stmts()

  // Manejo de ELSE
  (<ELSE> {
    // Se aumenta la etiqueta del final, por tener otro bloque previo
    LBLfin = etiqueta++;

    // Se muestra la etiqueta de fin y la que correspondería a falso 
    // (en este caso la etiqueta de falso sirve como el comienzo de otro bloque)
    System.out.println("vea LBL" + LBLfin);
    System.out.println("\nLBL" + LBLfalso++ + ":");
  }
  stmts()
  )?

  <END>{
    // Se establece la etiqueta de fin y se muesrta
    LBLfin = LBLfalso; 
    System.out.println("\nLBL" + LBLfin + ":");
  }
}

// Aceptador de operaciones de asignación
void assig() : {
  // Variables de control de asignación
  Token varAssign;
  Token expr;
  Token mulOrDiv = null;
  List<Token> opList = new ArrayList<>();
  String operation = "";
}
{
(
  (
    ( <MOVE>
    | <ADD> {operation = "add";}
    ) 
    (expr = expr() {
      // Se añade cada elemento que compone la expresión 
      opList.add(expr);
    })+ 
    <TO> {
      // Se evalua la expresión anterior en el orden correcto
      evalExpr(opList);
    }
  )

| (<SUBTRACT> 
  (expr = expr() 
    {
      // Cada elemento de la expresión se añade a la lista
      opList.add(expr);
    }
  )+ 
  <FROM> 
    {
      // Se evalua la expresión anterior en el orden correcto
      evalExpr(opList);

      // Se añade el sub
      operation = "sub";
    }
  )

| (
    (mulOrDiv = 
      <MULTIPLY>
      |<DIVIDE>){
        // Se comprueba el tipo de operación
        if(mulOrDiv.image == "MULTIPLY"){
          // Se asigna el operador de multiplicación
          operation = "mul";
        }else{
          // Se asigna el operador de división
          operation="div";}
        } 
    (expr())+ 
    <BY> 
    expr() 
    <GIVING>
    )
  )
  
  varAssign = <ID> {
    // Lógica de cierre de asignación, comprueba que no sea un MOVE
    if(operation != ""){
      // Se comprueba si es una suma
      if(operation == "add"){System.out.println("valord " + varAssign.image);}
        
      // Se comprueba si es una resta
      if(operation == "sub"){
        System.out.println("valord " + varAssign.image);
        System.out.println("swap");
      }

      // Se nuestra la operación a realizar
      System.out.println(operation);
    }
    
    // Finaliza la asignación poniendo en la pila la dirección de la variable 
    // Donde se almacena el valor a asignar
    System.out.println("valori " + varAssign.image);

    // Hace un cambio de los elementos de tope de pila y asigna
    System.out.println("swap\nasigna");
  }
}

// Aceptador para operaiones de entrada salida (I/O)
void io() : {
  // Variables para controlar la entrada y salida
  Token in;
  List<String> out = new ArrayList<String>();
  Token lit;
}
{
  <DISPLAY> 
  lit = literal() {
    // Se añade a la lista el elemento que se quiere imprimir
    out.add(lit.image);
  }
  ("," lit = literal() {
    // Tras el primer literal puede o no haber varios más
    out.add(lit.image);
  })*
  {
    // Bucle que recorre los elementos a imprimir
    for(String var : out){
      // Comprueba si el elemento es uan cadena (debe tener " o ' en su apertura)
      if(var.charAt(0) == '\'' || var.charAt(0) == '\"'){
        // Introduce la cadena a la pila
        System.out.println("metecad " + var);
      }else{
        // En el caso contrario introduce una variable a la pila
        System.out.println("valord " + var);
      }
    }
    // Muestra el número de elementos a imprimir
    System.out.println("print " + out.size());
  }
| <ACCEPT> in = <ID> {
    // Muestra lee + el ID de la variable que se lee
    System.out.println("lee " + in.image);
  }
} 

// Aceptador para expresiones atomicas 
Token atomic() : {Token val;}
{
  // Devuelve el valor leido
  val = <ID> {return val;} 
| val = <NUM> {return val;}
}

// Aceptador de expresiones literales
Token literal() : {
  Token token;
}
{
  // Devuelve el token leido
  token = <ID> {return token;}
| token = <NUM> {return token;}
| token = <CAD> {return token;}
}

// Aceptador para expresiones (llama a mult())
Token expr() : { Token token;}
{
  // Devueve el token leido
  token = <PLUS> {return token;} 
| token = <MINUS> {return token;}
| (token = mult() {return token;})
}

// Aceptador para multiplicaciones o valores (llama a val())
Token mult() : {Token token;}
{
  // Devuelve el token leido
  token = <PRODUCT> {return token;}
| token = <DIVISION> {return token;}
| (token = val() {return token;})
}

// Aceptador de valores numéricos, de texto o expresiones
Token val(): {
  Token token;
}
{
  token = <ID> {
    // Se introduce a la pila la variable y la devuelve
    System.out.println("valord " + token);
    return token;
  }
| token = <NUM> {
    // Se introduce a la pila la variable y la devuelve
    System.out.println("mete " + token);
    return token;
  }
| ("(" 
  token = expr() 
  ")" {
    // Devuelve la expresión
    return token;
  })
}

// Aceptador de expresiones booleanas
void booleanExpr() : {
  // Variable que contiene el tipo de comparador
  Token comparator;

  // Lista de términos que se comparan
  Token term;

  // Lista de términos que se compara
  List<Token> termList = new ArrayList<>();
  
  // Variable que comprueba si hay o no un lexema negador "NOT"
  boolean isNot = false;
}
{
  (term = expr() {
    // Se añaden los términos a comparar
    termList.add(term);
  })+ 
  {
    // Se evalua la expresión, separando términos y comparador
    evalExpr(termList);
  }
  <IS> 
  (<NOT> {isNot = true;})?
  (
    (comparator = <GREATER>
    | comparator = <LESS>
    ) <THAN>
    | comparator = <EQUAL> <TO>
  )
  expr()
  {
    // Se asigna el string adecuado según el comparador
    if(comparator.image == "GREATER"){System.out.println("esmayor");}
    if(comparator.image == "LESS"){System.out.println("esmenor");}
    if(comparator.image == "EQUAL"){System.out.println("esigual");}
  
    // Se comprueba si se ha negado lo anterior y se añade a la pila
    if(isNot){System.out.println("not");}
  }
}
